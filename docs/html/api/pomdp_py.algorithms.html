<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pomdp_py.algorithms package &#8212; pomdp_py 1.3.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=253395cc" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=0aabb5f1"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pomdp_py.framework package" href="pomdp_py.framework.html" />
    <link rel="prev" title="pomdp_py package" href="pomdp_py.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A framework to build and solve POMDP problems (v1.3.3).</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=h2r&repo=pomdp-py&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">pomdp_py.algorithms package</a><ul>
<li><a class="reference internal" href="#module-pomdp_py.algorithms.po_rollout">pomdp_py.algorithms.po_rollout module</a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout"><code class="docutils literal notranslate"><span class="pre">PORollout</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout.clear_agent"><code class="docutils literal notranslate"><span class="pre">PORollout.clear_agent()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout.last_best_reward"><code class="docutils literal notranslate"><span class="pre">PORollout.last_best_reward</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout.plan"><code class="docutils literal notranslate"><span class="pre">PORollout.plan()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout.set_rollout_policy"><code class="docutils literal notranslate"><span class="pre">PORollout.set_rollout_policy()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout.update"><code class="docutils literal notranslate"><span class="pre">PORollout.update()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout.update_agent_belief"><code class="docutils literal notranslate"><span class="pre">PORollout.update_agent_belief</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-pomdp_py.algorithms.po_uct">pomdp_py.algorithms.po_uct module</a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.ActionPrior"><code class="docutils literal notranslate"><span class="pre">ActionPrior</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.ActionPrior.get_preferred_actions"><code class="docutils literal notranslate"><span class="pre">ActionPrior.get_preferred_actions()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT"><code class="docutils literal notranslate"><span class="pre">POUCT</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT.clear_agent"><code class="docutils literal notranslate"><span class="pre">POUCT.clear_agent()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT.last_num_sims"><code class="docutils literal notranslate"><span class="pre">POUCT.last_num_sims</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT.last_planning_time"><code class="docutils literal notranslate"><span class="pre">POUCT.last_planning_time</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT.plan"><code class="docutils literal notranslate"><span class="pre">POUCT.plan()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT.set_rollout_policy"><code class="docutils literal notranslate"><span class="pre">POUCT.set_rollout_policy()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT.update"><code class="docutils literal notranslate"><span class="pre">POUCT.update()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT.updates_agent_belief"><code class="docutils literal notranslate"><span class="pre">POUCT.updates_agent_belief</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.QNode"><code class="docutils literal notranslate"><span class="pre">QNode</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.RandomRollout"><code class="docutils literal notranslate"><span class="pre">RandomRollout</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.RandomRollout.rollout"><code class="docutils literal notranslate"><span class="pre">RandomRollout.rollout()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.RolloutPolicy"><code class="docutils literal notranslate"><span class="pre">RolloutPolicy</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.RolloutPolicy.rollout"><code class="docutils literal notranslate"><span class="pre">RolloutPolicy.rollout()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.RootVNode"><code class="docutils literal notranslate"><span class="pre">RootVNode</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.RootVNode.from_vnode"><code class="docutils literal notranslate"><span class="pre">RootVNode.from_vnode()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.RootVNode.history"><code class="docutils literal notranslate"><span class="pre">RootVNode.history</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.TreeNode"><code class="docutils literal notranslate"><span class="pre">TreeNode</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.TreeNode.children"><code class="docutils literal notranslate"><span class="pre">TreeNode.children</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.TreeNode.num_visits"><code class="docutils literal notranslate"><span class="pre">TreeNode.num_visits</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.TreeNode.value"><code class="docutils literal notranslate"><span class="pre">TreeNode.value</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.VNode"><code class="docutils literal notranslate"><span class="pre">VNode</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.VNode.argmax"><code class="docutils literal notranslate"><span class="pre">VNode.argmax()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.VNode.print_children_value"><code class="docutils literal notranslate"><span class="pre">VNode.print_children_value()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.po_uct.VNode.value"><code class="docutils literal notranslate"><span class="pre">VNode.value</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-pomdp_py.algorithms.pomcp">pomdp_py.algorithms.pomcp module</a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.POMCP"><code class="docutils literal notranslate"><span class="pre">POMCP</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.POMCP.plan"><code class="docutils literal notranslate"><span class="pre">POMCP.plan()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.POMCP.update"><code class="docutils literal notranslate"><span class="pre">POMCP.update()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.POMCP.update_agent_belief"><code class="docutils literal notranslate"><span class="pre">POMCP.update_agent_belief</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.RootVNodeParticles"><code class="docutils literal notranslate"><span class="pre">RootVNodeParticles</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.RootVNodeParticles.belief"><code class="docutils literal notranslate"><span class="pre">RootVNodeParticles.belief</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.RootVNodeParticles.from_vnode"><code class="docutils literal notranslate"><span class="pre">RootVNodeParticles.from_vnode()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.VNodeParticles"><code class="docutils literal notranslate"><span class="pre">VNodeParticles</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.pomcp.VNodeParticles.belief"><code class="docutils literal notranslate"><span class="pre">VNodeParticles.belief</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-pomdp_py.algorithms.value_iteration">pomdp_py.algorithms.value_iteration module</a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.value_iteration.ValueIteration"><code class="docutils literal notranslate"><span class="pre">ValueIteration</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.value_iteration.ValueIteration.plan"><code class="docutils literal notranslate"><span class="pre">ValueIteration.plan()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-pomdp_py.algorithms.bsp.blqr">pomdp_py.algorithms.bsp.blqr module</a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.bsp.blqr.BLQR"><code class="docutils literal notranslate"><span class="pre">BLQR</span></code></a><ul>
<li><a class="reference internal" href="#pomdp_py.algorithms.bsp.blqr.BLQR.ekf_update_mlo"><code class="docutils literal notranslate"><span class="pre">BLQR.ekf_update_mlo()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.bsp.blqr.BLQR.integrate_belief_segment"><code class="docutils literal notranslate"><span class="pre">BLQR.integrate_belief_segment()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.bsp.blqr.BLQR.segmented_cost_function"><code class="docutils literal notranslate"><span class="pre">BLQR.segmented_cost_function()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.bsp.blqr.BLQR.create_plan"><code class="docutils literal notranslate"><span class="pre">BLQR.create_plan()</span></code></a></li>
<li><a class="reference internal" href="#pomdp_py.algorithms.bsp.blqr.BLQR.interpret_sqp_plan"><code class="docutils literal notranslate"><span class="pre">BLQR.interpret_sqp_plan()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#pomdp-py-algorithms-visual-visual-module">pomdp_py.algorithms.visual.visual module</a></li>
</ul>
</li>
</ul>

  </div><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design_principles.html">Design Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../existing_solvers.html">Existing POMDP Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">What's New?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API References</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">pomdp_py</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pomdp_py.html">pomdp_py package</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">pomdp_py.algorithms package</a></li>
<li class="toctree-l3"><a class="reference internal" href="pomdp_py.framework.html">pomdp_py.framework package</a></li>
<li class="toctree-l3"><a class="reference internal" href="pomdp_py.representations.html">pomdp_py.representations package</a></li>
<li class="toctree-l3"><a class="reference internal" href="pomdp_py.utils.html">pomdp_py.utils package</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../problems/modules.html">pomdp_problems</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://h2r.cs.brown.edu/">H2R lab</a></li>
    
    <li class="toctree-l1"><a href="http://kaiyuzh.me">Kaiyu's homepage</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="modules.html">pomdp_py</a><ul>
  <li><a href="pomdp_py.html">pomdp_py package</a><ul>
      <li>Previous: <a href="pomdp_py.html" title="previous chapter">pomdp_py package</a></li>
      <li>Next: <a href="pomdp_py.framework.html" title="next chapter">pomdp_py.framework package</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>


<h3 class="donation">Donate/support</h3>



<p>
<a class="badge" href="paypal.me/zkytony/10">
<img src="https://img.shields.io/badge/donate-%E2%9D%A4%C2%A0-ff69b4.svg?style=flat" alt="Donate">
</a>
</p>





        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pomdp-py-algorithms-package">
<h1>pomdp_py.algorithms package<a class="headerlink" href="#pomdp-py-algorithms-package" title="Permalink to this heading">¶</a></h1>
<p>Existing POMDP Solvers:</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pomdp_py.algorithms.po_rollout.PORollout" title="pomdp_py.algorithms.po_rollout.PORollout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PORollout</span></code></a></p></td>
<td><p>PO-rollout: Baseline algorithm in the POMCP paper</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT" title="pomdp_py.algorithms.po_uct.POUCT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">POUCT</span></code></a></p></td>
<td><p>POUCT (Partially Observable UCT) <span id="id1">[<a class="reference internal" href="#id33" title="David Silver and Joel Veness. Monte-carlo planning in large pomdps. In Advances in neural information processing systems, 2164–2172. 2010.">2</a>]</span> is presented in the POMCP paper as an extension of the UCT algorithm to partially-observable domains that combines MCTS and UCB1 for action selection.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pomdp_py.algorithms.pomcp.POMCP" title="pomdp_py.algorithms.pomcp.POMCP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">POMCP</span></code></a></p></td>
<td><p>POMCP is POUCT + particle belief representation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pomdp_py.algorithms.value_iteration.ValueIteration" title="pomdp_py.algorithms.value_iteration.ValueIteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ValueIteration</span></code></a></p></td>
<td><p>This algorithm is only feasible for small problems where states, actions, and observations can be explicitly enumerated.</p></td>
</tr>
</tbody>
</table>
<p>Solvers under development (<strong>contribution wanted</strong>):</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-pomdp_py.algorithms.bsp.blqr" title="pomdp_py.algorithms.bsp.blqr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blqr</span></code></a></p></td>
<td><p>Implementation of B-LQR algorithm described in &quot;Belief space planning assuming maximum likelihood observations&quot; <span id="id2">[<a class="reference internal" href="#id43" title="R. Platt, R. Tedrake, L. Kaelbling, and T. Lozano-Perez. Belief space planning assuming maximum likelihood observations. In Proceedings of Robotics: Science and Systems. Zaragoza, Spain, June 2010. doi:10.15607/RSS.2010.VI.037.">4</a>]</span></p></td>
</tr>
</tbody>
</table>
<section id="module-pomdp_py.algorithms.po_rollout">
<span id="pomdp-py-algorithms-po-rollout-module"></span><h2>pomdp_py.algorithms.po_rollout module<a class="headerlink" href="#module-pomdp_py.algorithms.po_rollout" title="Permalink to this heading">¶</a></h2>
<p>PO-rollout: Baseline algorithm in the POMCP paper <span id="id3">[<a class="reference internal" href="#id33" title="David Silver and Joel Veness. Monte-carlo planning in large pomdps. In Advances in neural information processing systems, 2164–2172. 2010.">2</a>]</span>.</p>
<p>Quote from the POMCP paper:</p>
<blockquote>
<div><p>To provide a performance benchmark in these cases, we evaluated the
performance of simple Monte-Carlo simulation without any tree.
The PO-rollout algorithm used Monte-Carlo belief state updates,
as described in section 3.2. It then simulated <span class="math notranslate nohighlight">\(n/|A|\)</span> rollouts for
each legal action, and selected the action with highest average return.</p>
</div></blockquote>
<p>We don’t require Monte-Carlo belief update (it’s an option). But
it will do the rollouts and action selection as described.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_rollout.PORollout">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_rollout.</span></span><span class="sig-name descname"><span class="pre">PORollout</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_rollout.PORollout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pomdp_py.framework.html#pomdp_py.framework.planner.Planner" title="pomdp_py.framework.planner.Planner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Planner</span></code></a></p>
<p>PO-rollout: Baseline algorithm in the POMCP paper</p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_rollout.PORollout.clear_agent">
<span class="sig-name descname"><span class="pre">clear_agent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_rollout.PORollout.clear_agent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_rollout.PORollout.last_best_reward">
<span class="sig-name descname"><span class="pre">last_best_reward</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_rollout.PORollout.last_best_reward" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_rollout.PORollout.plan">
<span class="sig-name descname"><span class="pre">plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Agent</span> <span class="pre">agent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_rollout.PORollout.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>The agent carries the information:
Bt, ht, O,T,R/G, pi, necessary for planning</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_rollout.PORollout.set_rollout_policy">
<span class="sig-name descname"><span class="pre">set_rollout_policy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RolloutPolicy</span> <span class="pre">rollout_policy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_rollout.PORollout.set_rollout_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the rollout policy to the given one</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_rollout.PORollout.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Agent</span> <span class="pre">agent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Action</span> <span class="pre">real_action</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Observation</span> <span class="pre">real_observation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_rollout.PORollout.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the planner based on real action and observation.
Updates the agent accordingly if necessary. If the agent’s
belief is also updated here, the <cite>update_agent_belief</cite>
attribute should be set to True. By default, does nothing.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_rollout.PORollout.update_agent_belief">
<span class="sig-name descname"><span class="pre">update_agent_belief</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_rollout.PORollout.update_agent_belief" title="Permalink to this definition">¶</a></dt>
<dd><p>True if planner’s update function also updates agent’s
belief.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pomdp_py.algorithms.po_uct">
<span id="pomdp-py-algorithms-po-uct-module"></span><h2>pomdp_py.algorithms.po_uct module<a class="headerlink" href="#module-pomdp_py.algorithms.po_uct" title="Permalink to this heading">¶</a></h2>
<p>This algorithm is PO-UCT (Partially Observable UCT). It is
presented in the POMCP paper <span id="id4">[<a class="reference internal" href="#id33" title="David Silver and Joel Veness. Monte-carlo planning in large pomdps. In Advances in neural information processing systems, 2164–2172. 2010.">2</a>]</span> as an extension to the UCT
algorithm <span id="id5">[<a class="reference internal" href="#id42" title="Levente Kocsis and Csaba Szepesvári. Bandit based monte-carlo planning. In European conference on machine learning, 282–293. Springer, 2006.">3</a>]</span> that combines MCTS and UCB1
for action selection.</p>
<p>In other words, this is just POMCP without particle belief,
but arbitrary belief representation.</p>
<p>This planning strategy, based on MCTS with belief sampling may be referred to as
“belief sparse sampling”; Partially Observable Sparse Sampling (POSS) is
introduced in a recent paper <span id="id6">[<a class="reference internal" href="#id53" title="Michael H Lim, Claire J Tomlin, and Zachary N Sunberg. Sparse tree search optimality guarantees in pomdps with continuous observation spaces. arXiv preprint arXiv:1910.04332, 2019.">5</a>]</span> as an extension of sparse sampling
for MDP by <span id="id7">[<a class="reference internal" href="#id52" title="Michael Kearns, Yishay Mansour, and Andrew Y Ng. A sparse sampling algorithm for near-optimal planning in large markov decision processes. Machine learning, 49(2-3):193–208, 2002.">6</a>]</span>; It proposes an extension of POSS
called POWSS (partially observable weighted sparse sampling).  However, this
line of work (POSS, POWSS) is based solely on particle belief
representation. POSS still requires comparing observations exactly for particle
belief update, while POWSS uses weighted particles depending on the observation
distribution.</p>
<p>A note on the exploration constant. Quote from <span id="id8">[<a class="reference internal" href="#id54" title="António Gusmao and Tapani Raiko. Towards generalizing the success of monte-carlo tree search beyond the game of go. In ECAI, 384–389. 2012.">7</a>]</span>:</p>
<blockquote>
<div><p>“This constant should reflect the agent’s prior knowledge regarding
the amount of exploration required.”</p>
</div></blockquote>
<p>In the POMCP paper, they set this constant following:</p>
<blockquote>
<div><p>“The exploration constant for POMCP was set to <span class="math notranslate nohighlight">\(c = R_{hi} - R_{lo}\)</span>,
where Rhi was the highest return achieved during sample runs of POMCP
with <span class="math notranslate nohighlight">\(c = 0\)</span>, and Rlo was the lowest return achieved during sample rollouts”</p>
</div></blockquote>
<p>It is then clear that the POMCP paper is indeed setting this constant
based on prior knowledge. Note the difference between <cite>sample runs</cite> and
<cite>sample rollouts</cite>. But, this is certainly not the only way to obtainx1
the prior knowledge.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.ActionPrior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">ActionPrior</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.ActionPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A problem-specific object</p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.ActionPrior.get_preferred_actions">
<span class="sig-name descname"><span class="pre">get_preferred_actions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.ActionPrior.get_preferred_actions" title="Permalink to this definition">¶</a></dt>
<dd><p>Intended as a classmethod.
This is to mimic the behavior of Simulator.Prior
and GenerateLegal/GeneratePreferred in David Silver’s
POMCP code.</p>
<p>Returns a set of tuples, in the form of (action, num_visits_init, value_init)
that represent the preferred actions.
In POMCP, this acts as a history-based prior policy,
and in DESPOT, this acts as a belief-based prior policy.
For example, given certain state or history, only it
is possible that only a subset of all actions is legal;
This is useful when there is domain knowledge that can
be used as a heuristic for planning.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">POUCT</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pomdp_py.framework.html#pomdp_py.framework.planner.Planner" title="pomdp_py.framework.planner.Planner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Planner</span></code></a></p>
<p>POUCT (Partially Observable UCT) <span id="id9">[<a class="reference internal" href="#id33" title="David Silver and Joel Veness. Monte-carlo planning in large pomdps. In Advances in neural information processing systems, 2164–2172. 2010.">2</a>]</span> is presented in the POMCP
paper as an extension of the UCT algorithm to partially-observable domains
that combines MCTS and UCB1 for action selection.</p>
<p>POUCT only works for problems with action space that can be enumerated.</p>
<dl class="simple">
<dt>__init__(self,</dt><dd><p>max_depth=5, planning_time=1., num_sims=-1,
discount_factor=0.9, exploration_const=math.sqrt(2),
num_visits_init=1, value_init=0,
rollout_policy=RandomRollout(),
action_prior=None, show_progress=False, pbar_update_interval=5)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_depth</strong> (<em>int</em>) – Depth of the MCTS tree. Default: 5.</p></li>
<li><p><strong>planning_time</strong> (<em>float</em><em>)</em><em>, </em><em>amount</em><em> of </em><em>time given to each planning step</em><em> (</em><em>seconds</em>) – -1.
if negative, then planning terminates when number of simulations <cite>num_sims</cite> reached.
If both <cite>num_sims</cite> and <cite>planning_time</cite> are negative, then the planner will run for 1 second.</p></li>
<li><p><strong>num_sims</strong> (<em>int</em>) – Number of simulations for each planning step. If negative,
then will terminate when planning_time is reached.
If both <cite>num_sims</cite> and <cite>planning_time</cite> are negative, then the planner will run for 1 second.</p></li>
<li><p><strong>rollout_policy</strong> (<a class="reference internal" href="#pomdp_py.algorithms.po_uct.RolloutPolicy" title="pomdp_py.algorithms.po_uct.RolloutPolicy"><em>RolloutPolicy</em></a>) – rollout policy. Default: RandomRollout.</p></li>
<li><p><strong>action_prior</strong> (<a class="reference internal" href="#pomdp_py.algorithms.po_uct.ActionPrior" title="pomdp_py.algorithms.po_uct.ActionPrior"><em>ActionPrior</em></a>) – a prior over preferred actions given state and history.</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em>) – True if print a progress bar for simulations.</p></li>
<li><p><strong>pbar_update_interval</strong> (<em>int</em>) – The number of simulations to run after each update of the progress bar,
Only useful if show_progress is True; You can set this parameter even if your stopping criteria
is time.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT.clear_agent">
<span class="sig-name descname"><span class="pre">clear_agent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT.clear_agent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT.last_num_sims">
<span class="sig-name descname"><span class="pre">last_num_sims</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT.last_num_sims" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of simulations ran for the last <cite>plan</cite> call.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT.last_planning_time">
<span class="sig-name descname"><span class="pre">last_planning_time</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT.last_planning_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the amount of time (seconds) ran for the last <cite>plan</cite> call.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT.plan">
<span class="sig-name descname"><span class="pre">plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Agent</span> <span class="pre">agent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>The agent carries the information:
Bt, ht, O,T,R/G, pi, necessary for planning</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT.set_rollout_policy">
<span class="sig-name descname"><span class="pre">set_rollout_policy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RolloutPolicy</span> <span class="pre">rollout_policy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT.set_rollout_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the rollout policy to the given one</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Agent</span> <span class="pre">agent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Action</span> <span class="pre">real_action</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Observation</span> <span class="pre">real_observation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that the agent’s history has been updated after taking real_action
and receiving real_observation.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.POUCT.updates_agent_belief">
<span class="sig-name descname"><span class="pre">updates_agent_belief</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.POUCT.updates_agent_belief" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.QNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">QNode</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.QNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pomdp_py.algorithms.po_uct.TreeNode" title="pomdp_py.algorithms.po_uct.TreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeNode</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.RandomRollout">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">RandomRollout</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.RandomRollout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pomdp_py.algorithms.po_uct.RolloutPolicy" title="pomdp_py.algorithms.po_uct.RolloutPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">RolloutPolicy</span></code></a></p>
<p>A rollout policy that chooses actions uniformly at random from the set of
possible actions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.RandomRollout.rollout">
<span class="sig-name descname"><span class="pre">rollout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">State</span> <span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tuple</span> <span class="pre">history=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.RandomRollout.rollout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.RolloutPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">RolloutPolicy</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.RolloutPolicy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pomdp_py.framework.html#pomdp_py.framework.basics.PolicyModel" title="pomdp_py.framework.basics.PolicyModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolicyModel</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.RolloutPolicy.rollout">
<span class="sig-name descname"><span class="pre">rollout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">State</span> <span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tuple</span> <span class="pre">history=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.RolloutPolicy.rollout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.RootVNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">RootVNode</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.RootVNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pomdp_py.algorithms.po_uct.VNode" title="pomdp_py.algorithms.po_uct.VNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">VNode</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.RootVNode.from_vnode">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_vnode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vnode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.RootVNode.from_vnode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.RootVNode.history">
<span class="sig-name descname"><span class="pre">history</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.RootVNode.history" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.TreeNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">TreeNode</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.TreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.TreeNode.children">
<span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.TreeNode.children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.TreeNode.num_visits">
<span class="sig-name descname"><span class="pre">num_visits</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.TreeNode.num_visits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.TreeNode.value">
<span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.TreeNode.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.VNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.po_uct.</span></span><span class="sig-name descname"><span class="pre">VNode</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.VNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pomdp_py.algorithms.po_uct.TreeNode" title="pomdp_py.algorithms.po_uct.TreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeNode</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.VNode.argmax">
<span class="sig-name descname"><span class="pre">argmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">VNode</span> <span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.VNode.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the action of the child with highest value</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.VNode.print_children_value">
<span class="sig-name descname"><span class="pre">print_children_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.VNode.print_children_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.po_uct.VNode.value">
<span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pomdp_py.algorithms.po_uct.VNode.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-pomdp_py.algorithms.pomcp">
<span id="pomdp-py-algorithms-pomcp-module"></span><h2>pomdp_py.algorithms.pomcp module<a class="headerlink" href="#module-pomdp_py.algorithms.pomcp" title="Permalink to this heading">¶</a></h2>
<p>We implement POMCP as described in the original paper
Monte-Carlo Planning in Large POMDPs
<a class="reference external" href="https://papers.nips.cc/paper/4031-monte-carlo-planning-in-large-pomdps">https://papers.nips.cc/paper/4031-monte-carlo-planning-in-large-pomdps</a></p>
<p>One thing to note is that, in this algorithm, belief
update happens as the simulation progresses. The new
belief is stored in the vnodes at the level after
executing the next action. These particles will
be reinvigorated if they are not enough.</p>
<p>However, it is possible to separate MCTS completely
from the belief update. This means the belief nodes
no longer keep track of particles, and belief update
and particle reinvogration happen for once after MCTS
is completed. I have previously implemented this version.
This version is also implemented in BasicPOMCP.jl
(<a class="reference external" href="https://github.com/JuliaPOMDP/BasicPOMCP.jl">https://github.com/JuliaPOMDP/BasicPOMCP.jl</a>)
The two should be EQUIVALENT. In general, it doesn’t
hurt to do the belief update during MCTS, a feature
of using particle representation.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.POMCP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.pomcp.</span></span><span class="sig-name descname"><span class="pre">POMCP</span></span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.POMCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pomdp_py.algorithms.po_uct.POUCT" title="pomdp_py.algorithms.po_uct.POUCT"><code class="xref py py-class docutils literal notranslate"><span class="pre">POUCT</span></code></a></p>
<p>POMCP is POUCT + particle belief representation.
This POMCP version only works for problems
with action space that can be enumerated.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.POMCP.plan">
<span class="sig-name descname"><span class="pre">plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Agent</span> <span class="pre">agent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.POMCP.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>The agent carries the information:
Bt, ht, O,T,R/G, pi, necessary for planning</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.POMCP.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">agent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">real_action</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">real_observation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_transform_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.POMCP.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that the agent’s history has been updated after taking real_action
and receiving real_observation.</p>
<dl class="simple">
<dt><cite>state_transform_func</cite>: Used to add artificial transform to states during</dt><dd><p>particle reinvigoration. Signature: s -&gt; s_transformed</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.POMCP.update_agent_belief">
<span class="sig-name descname"><span class="pre">update_agent_belief</span></span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.POMCP.update_agent_belief" title="Permalink to this definition">¶</a></dt>
<dd><p>True if planner’s update function also updates agent’s
belief.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.RootVNodeParticles">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.pomcp.</span></span><span class="sig-name descname"><span class="pre">RootVNodeParticles</span></span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.RootVNodeParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pomdp_py.algorithms.po_uct.RootVNode" title="pomdp_py.algorithms.po_uct.RootVNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootVNode</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.RootVNodeParticles.belief">
<span class="sig-name descname"><span class="pre">belief</span></span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.RootVNodeParticles.belief" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.RootVNodeParticles.from_vnode">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_vnode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vnode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.RootVNodeParticles.from_vnode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.VNodeParticles">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.pomcp.</span></span><span class="sig-name descname"><span class="pre">VNodeParticles</span></span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.VNodeParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pomdp_py.algorithms.po_uct.VNode" title="pomdp_py.algorithms.po_uct.VNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">VNode</span></code></a></p>
<p>POMCP’s VNode maintains particle belief</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pomdp_py.algorithms.pomcp.VNodeParticles.belief">
<span class="sig-name descname"><span class="pre">belief</span></span><a class="headerlink" href="#pomdp_py.algorithms.pomcp.VNodeParticles.belief" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-pomdp_py.algorithms.value_iteration">
<span id="pomdp-py-algorithms-value-iteration-module"></span><h2>pomdp_py.algorithms.value_iteration module<a class="headerlink" href="#module-pomdp_py.algorithms.value_iteration" title="Permalink to this heading">¶</a></h2>
<p>Implementation of the basic policy tree based value iteration as explained
in section 4.1 of <cite>Planning and acting in partially observable stochastic
domains</cite> <span id="id10">[<a class="reference internal" href="#id31" title="Leslie Pack Kaelbling, Michael L Littman, and Anthony R Cassandra. Planning and acting in partially observable stochastic domains. Artificial intelligence, 101(1-2):99–134, 1998.">1</a>]</span></p>
<p>Warning: No pruning - the number of policy trees explodes very fast.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.value_iteration.ValueIteration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.value_iteration.</span></span><span class="sig-name descname"><span class="pre">ValueIteration</span></span><a class="headerlink" href="#pomdp_py.algorithms.value_iteration.ValueIteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pomdp_py.framework.html#pomdp_py.framework.planner.Planner" title="pomdp_py.framework.planner.Planner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Planner</span></code></a></p>
<p>This algorithm is only feasible for small problems where states, actions,
and observations can be explicitly enumerated.</p>
<p>__init__(self, horizon=float(‘inf’), discount_factor=0.9, epsilon=1e-6)</p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.value_iteration.ValueIteration.plan">
<span class="sig-name descname"><span class="pre">plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pomdp_py.algorithms.value_iteration.ValueIteration.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Plans an action.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pomdp_py.algorithms.bsp.blqr">
<span id="pomdp-py-algorithms-bsp-blqr-module"></span><h2>pomdp_py.algorithms.bsp.blqr module<a class="headerlink" href="#module-pomdp_py.algorithms.bsp.blqr" title="Permalink to this heading">¶</a></h2>
<p>Implementation of B-LQR algorithm described in “Belief space planning
assuming maximum likelihood observations” <span id="id11">[<a class="reference internal" href="#id43" title="R. Platt, R. Tedrake, L. Kaelbling, and T. Lozano-Perez. Belief space planning assuming maximum likelihood observations. In Proceedings of Robotics: Science and Systems. Zaragoza, Spain, June 2010. doi:10.15607/RSS.2010.VI.037.">4</a>]</span></p>
<dl class="py class">
<dt class="sig sig-object py" id="pomdp_py.algorithms.bsp.blqr.BLQR">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pomdp_py.algorithms.bsp.blqr.</span></span><span class="sig-name descname"><span class="pre">BLQR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_sysd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac_sysd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac_sysd_u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_sysd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Qlarge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">planning_horizon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pomdp_py/algorithms/bsp/blqr.html#BLQR"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pomdp_py.algorithms.bsp.blqr.BLQR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pomdp_py.framework.html#pomdp_py.framework.planner.Planner" title="pomdp_py.framework.planner.Planner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Planner</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.bsp.blqr.BLQR.ekf_update_mlo">
<span class="sig-name descname"><span class="pre">ekf_update_mlo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ut</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pomdp_py/algorithms/bsp/blqr.html#BLQR.ekf_update_mlo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pomdp_py.algorithms.bsp.blqr.BLQR.ekf_update_mlo" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the ekf belief update assuming maximum likelihood observation.
This follows equations 12, 13 in the paper. It’s the function <span class="math notranslate nohighlight">\(F\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bt</strong> (<em>tuple</em>) – a belief point bt = (mt, Cov_t) representing the belief state.
where mt is np.array of shape (d,) and Cov_t is np.array of shape (d,d).
The cost function equation needs to turn Cov_t into a long vector consist
of the columns of Cov_t stiched together.</p></li>
<li><p><strong>ut</strong> (<em>np.array</em>) – control vector</p></li>
<li><p><strong>noise_t</strong> (<em>pomdp_py.Gaussian</em>) – The Gaussian noise with “possibly state-dependent”
covariance matrix Wt.</p></li>
<li><p><strong>noise_sysd</strong> (<em>np.array</em>) – A noise term (e.g. Gaussian noise) added to the
system dynamics (<span class="math notranslate nohighlight">\(v\)</span> in Eq.12). This array should have the sam
dimensionality as mt.</p></li>
<li><p><strong>noise_obs_cov</strong> (<em>np.array</em>) – The covariance matrix of the Gaussian noise of the
observation function. This corresponds to Wt in equation 13.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.bsp.blqr.BLQR.integrate_belief_segment">
<span class="sig-name descname"><span class="pre">integrate_belief_segment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pomdp_py/algorithms/bsp/blqr.html#BLQR.integrate_belief_segment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pomdp_py.algorithms.bsp.blqr.BLQR.integrate_belief_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>This is to represent equation 18.</p>
<dl class="simple">
<dt>phi(b_i’, u_i’) = F(b_i’, u_i’) +   sum    F(b_{t+1}, u_i) - F(b_t, u_i)</dt><dd><p>t in seg</p>
</dd>
</dl>
<p>This essentially returns b_{i+1}’</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.bsp.blqr.BLQR.segmented_cost_function">
<span class="sig-name descname"><span class="pre">segmented_cost_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bu_traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_des</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_des</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pomdp_py/algorithms/bsp/blqr.html#BLQR.segmented_cost_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pomdp_py.algorithms.bsp.blqr.BLQR.segmented_cost_function" title="Permalink to this definition">¶</a></dt>
<dd><p>The cost function in eq 17.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b_des</strong> (<em>tuple</em>) – The desired belief (mT, CovT). This is needed to compute the cost function.</p></li>
<li><p><strong>u_des</strong> (<em>list</em>) – A list of desired controls at the beginning of each segment.
If this information is not available, pass in an empty list.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.bsp.blqr.BLQR.create_plan">
<span class="sig-name descname"><span class="pre">create_plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_des</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pomdp_py/algorithms/bsp/blqr.html#BLQR.create_plan"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pomdp_py.algorithms.bsp.blqr.BLQR.create_plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the SQP problem using direct transcription, and produce belief points
and controls at segments.
Reference: <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pomdp_py.algorithms.bsp.blqr.BLQR.interpret_sqp_plan">
<span class="sig-name descname"><span class="pre">interpret_sqp_plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opt_res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pomdp_py/algorithms/bsp/blqr.html#BLQR.interpret_sqp_plan"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pomdp_py.algorithms.bsp.blqr.BLQR.interpret_sqp_plan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="pomdp-py-algorithms-visual-visual-module">
<h2>pomdp_py.algorithms.visual.visual module<a class="headerlink" href="#pomdp-py-algorithms-visual-visual-module" title="Permalink to this heading">¶</a></h2>
<div class="docutils container" id="id12">
<div role="list" class="citation-list">
<div class="citation" id="id31" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">1</a><span class="fn-bracket">]</span></span>
<p>Leslie Pack Kaelbling, Michael L Littman, and Anthony R Cassandra. Planning and acting in partially observable stochastic domains. <em>Artificial intelligence</em>, 101(1-2):99–134, 1998.</p>
</div>
<div class="citation" id="id33" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id1">2</a>,<a role="doc-backlink" href="#id3">3</a>,<a role="doc-backlink" href="#id4">4</a>,<a role="doc-backlink" href="#id9">5</a>)</span>
<p>David Silver and Joel Veness. Monte-carlo planning in large pomdps. In <em>Advances in neural information processing systems</em>, 2164–2172. 2010.</p>
</div>
<div class="citation" id="id42" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">3</a><span class="fn-bracket">]</span></span>
<p>Levente Kocsis and Csaba Szepesvári. Bandit based monte-carlo planning. In <em>European conference on machine learning</em>, 282–293. Springer, 2006.</p>
</div>
<div class="citation" id="id43" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id11">3</a>)</span>
<p>R. Platt, R. Tedrake, L. Kaelbling, and T. Lozano-Perez. Belief space planning assuming maximum likelihood observations. In <em>Proceedings of Robotics: Science and Systems</em>. Zaragoza, Spain, June 2010. <a class="reference external" href="https://doi.org/10.15607/RSS.2010.VI.037">doi:10.15607/RSS.2010.VI.037</a>.</p>
</div>
<div class="citation" id="id53" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">5</a><span class="fn-bracket">]</span></span>
<p>Michael H Lim, Claire J Tomlin, and Zachary N Sunberg. Sparse tree search optimality guarantees in pomdps with continuous observation spaces. <em>arXiv preprint arXiv:1910.04332</em>, 2019.</p>
</div>
<div class="citation" id="id52" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">6</a><span class="fn-bracket">]</span></span>
<p>Michael Kearns, Yishay Mansour, and Andrew Y Ng. A sparse sampling algorithm for near-optimal planning in large markov decision processes. <em>Machine learning</em>, 49(2-3):193–208, 2002.</p>
</div>
<div class="citation" id="id54" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">7</a><span class="fn-bracket">]</span></span>
<p>António Gusmao and Tapani Raiko. Towards generalizing the success of monte-carlo tree search beyond the game of go. In <em>ECAI</em>, 384–389. 2012.</p>
</div>
</div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020-2021, H2R@Brown.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/api/pomdp_py.algorithms.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>